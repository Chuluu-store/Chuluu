import { NextRequest, NextResponse } from 'next/server';
import { writeFile, mkdir, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import ExifReader from 'exifreader';
import sharp from 'sharp';
import path from 'path';

import { env } from '../../../../shared/config/env';
import { verifyToken } from '../../../../shared/lib/auth';
import { connectDB } from '../../../../shared/lib/database';
import { Media } from '../../../../entities/media/model/media.model';
import { Group } from '../../../../entities/group/model/group.model';
import {
  parseExifFromFile,
  parseHeicExifBuffer,
  parseExifFromBuffer,
  normalizeMetadata,
} from '../../../../shared/lib/exif-utils';
import { convertHeicToThumbnail } from '../../../../shared/lib/heic-converter';

// ÏóÖÎ°úÎìú ÏÑ§Ï†ï
export const runtime = 'nodejs';
export const maxDuration = 300; // 5Î∂Ñ ÌÉÄÏûÑÏïÑÏõÉ

export async function POST(request: NextRequest) {
  console.log('üìÅ Direct file upload started');
  try {
    await connectDB();

    // ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    if (!token) {
      console.error('‚ùå No token provided');
      return NextResponse.json({ error: 'Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§' }, { status: 401 });
    }

    const decoded = await verifyToken(token);
    if (!decoded) {
      return NextResponse.json({ error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;
    const groupId = formData.get('groupId') as string;

    console.log('üìã Upload request details:', {
      fileName: file?.name,
      fileSize: file?.size,
      groupId,
    });

    if (!file || !groupId) {
      console.error('‚ùå Missing required fields:', {
        file: !!file,
        groupId: !!groupId,
      });
      return NextResponse.json({ error: 'ÌååÏùºÍ≥º Í∑∏Î£π IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§' }, { status: 400 });
    }

    // Í∑∏Î£π ÌôïÏù∏ Î∞è Í∂åÌïú Ï≤¥ÌÅ¨
    const group = await Group.findById(groupId);
    if (!group) {
      return NextResponse.json({ error: 'Í∑∏Î£πÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§' }, { status: 404 });
    }

    // Í∑∏Î£π Î©§Î≤Ñ Í∂åÌïú ÌôïÏù∏
    if (!group.members.includes(decoded.userId)) {
      return NextResponse.json({ error: 'Í∑∏Î£πÏóê ÏóÖÎ°úÎìúÌï† Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§' }, { status: 403 });
    }

    // ÌååÏùº ÌÅ¨Í∏∞ Ï†úÌïú (500MB)
    const maxSize = 500 * 1024 * 1024; // 500MB
    if (file.size > maxSize) {
      return NextResponse.json({ error: 'ÌååÏùº ÌÅ¨Í∏∞Îäî ÏµúÎåÄ 500MBÍπåÏßÄ ÏóÖÎ°úÎìúÌï† Ïàò ÏûàÏäµÎãàÎã§' }, { status: 400 });
    }

    // ÏßÄÏõêÎêòÎäî ÌååÏùº ÌÉÄÏûÖ ÌôïÏù∏ - ÌôïÏû•Ïûê Ïö∞ÏÑ† Ï≤¥ÌÅ¨
    const fileExt = path.extname(file.name).toLowerCase().slice(1);
    const supportedExtensions = [
      // Ïù¥ÎØ∏ÏßÄ
      'jpg',
      'jpeg',
      'png',
      'gif',
      'webp',
      'bmp',
      'tiff',
      'tif',
      'svg',
      'heic',
      'heif',
      // ÎπÑÎîîÏò§
      'mp4',
      'avi',
      'mov',
      'mkv',
      'wmv',
      'flv',
      'webm',
      '3gp',
      'm4v',
    ];

    // ÌôïÏû•ÏûêÎ°ú Î®ºÏ†Ä Ï≤¥ÌÅ¨
    if (!supportedExtensions.includes(fileExt)) {
      // MIME ÌÉÄÏûÖÏúºÎ°ú Ïû¨ÌôïÏù∏
      const supportedTypes = [
        // Ïù¥ÎØ∏ÏßÄ
        'image/jpeg',
        'image/jpg',
        'image/png',
        'image/gif',
        'image/webp',
        'image/bmp',
        'image/tiff',
        'image/svg+xml',
        'image/heic',
        'image/heif',
        // ÎπÑÎîîÏò§
        'video/mp4',
        'video/avi',
        'video/mov',
        'video/quicktime',
        'video/mkv',
        'video/wmv',
        'video/flv',
        'video/webm',
        'video/3gp',
        'video/m4v',
        'video/x-msvideo',
        'video/x-matroska',
      ];

      if (!supportedTypes.includes(file.type)) {
        return NextResponse.json(
          { error: `ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§: ${file.name} (${file.type || 'unknown type'})` },
          { status: 400 }
        );
      }
    }

    console.log(`‚úÖ File type accepted: ${file.name} (ext: ${fileExt}, type: ${file.type})`);

    // ÏóÖÎ°úÎìú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
    const uploadDir = env.UPLOAD_PATH || '/tmp/uploads';
    const groupDir = path.join(uploadDir, groupId);

    if (!existsSync(groupDir)) {
      await mkdir(groupDir, { recursive: true });
    }

    // ÌååÏùº Ï†ÄÏû• - EXIF Ï†ïÎ≥¥ Î≥¥Ï°¥ÏùÑ ÏúÑÌï¥ ÏõêÎ≥∏ Í∑∏ÎåÄÎ°ú Ï†ÄÏû•
    const timestamp = Date.now();
    const originalName = file.name;
    const extension = path.extname(originalName);
    const fileName = `${timestamp}_${originalName.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
    const filePath = path.join(groupDir, fileName);

    // ArrayBufferÎ°ú ÏßÅÏ†ë Ï†ÄÏû• (EXIF Ï†ïÎ≥¥ Î≥¥Ï°¥)
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filePath, buffer);

    console.log(`‚úÖ File saved with EXIF preserved: ${filePath}`);

    // EXIF Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú - fsÎ°ú ÌååÏùºÏóêÏÑú ÏßÅÏ†ë ÏùΩÍ∏∞ (ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Î≥¥Ï°¥)
    let metadata: any = {};
    try {
      // Î™®Îì† Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏóê ÎåÄÌï¥ fsÎ°ú EXIF ÏßÅÏ†ë Ï∂îÏ∂ú
      if (
        file.type.startsWith('image/') ||
        file.name.toLowerCase().endsWith('.heic') ||
        file.name.toLowerCase().endsWith('.heif')
      ) {
        console.log('üì∑ Processing image file with fs:', file.name, 'Type:', file.type);

        // fsÎ°ú ÌååÏùºÏóêÏÑú ÏßÅÏ†ë EXIF ÏùΩÍ∏∞
        const exifData = await parseExifFromFile(filePath);

        if (exifData) {
          console.log('‚úÖ EXIF extracted successfully:', {
            make: exifData.make,
            model: exifData.model,
            dateTimeOriginal: exifData.dateTimeOriginal,
            iso: exifData.iso,
            gps: exifData.gps ? 'GPS data found' : 'No GPS',
            totalTags: exifData.allTags ? Object.keys(exifData.allTags).length : 0,
          });
          metadata = exifData;
        } else {
          // EXIF Ï∂îÏ∂ú Ïã§Ìå® Ïãú SharpÎ°ú Í∏∞Î≥∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Îßå Ï∂îÏ∂ú
          console.log('‚ö†Ô∏è EXIF extraction failed, using Sharp for basic metadata');
          try {
            const sharpMetadata = await sharp(filePath).metadata();
            metadata = {
              width: sharpMetadata.width,
              height: sharpMetadata.height,
              format: sharpMetadata.format,
              orientation: sharpMetadata.orientation,
            };

            // SharpÏùò EXIF Î≤ÑÌçºÍ∞Ä ÏûàÏúºÎ©¥ ÌååÏã± ÏãúÎèÑ
            if (sharpMetadata.exif) {
              const parsedExif = parseHeicExifBuffer(sharpMetadata.exif);
              if (parsedExif) {
                metadata = { ...metadata, ...parsedExif };
              }
            }
          } catch (sharpError) {
            console.error('‚ö†Ô∏è Sharp metadata extraction also failed:', sharpError);
          }
        }
      } else if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mov')) {
        // ÎπÑÎîîÏò§ ÌååÏùºÏùò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÎèÑ (MOV ÌååÏùº ÌäπÎ≥Ñ Ï≤òÎ¶¨)
        console.log(`üé¨ Processing video file: ${file.name}`);

        try {
          // ExifReaderÎ°ú Î®ºÏ†Ä ÏãúÎèÑ (ÌäπÌûà iPhone MOV ÌååÏùºÏóê Ìö®Í≥ºÏ†Å)
          const fileBuffer = await readFile(filePath);
          const tags = ExifReader.load(fileBuffer);

          // GPS Ï†ïÎ≥¥ Ï∂îÏ∂ú
          let gpsData = null;
          if (tags['GPSLatitude'] && tags['GPSLongitude']) {
            // GPS Ï¢åÌëú Î≥ÄÌôò (ÎèÑÎ∂ÑÏ¥à ‚Üí Ïã≠ÏßÑÎ≤ï)
            const convertGPS = (value: any): number | null => {
              if (!value || !Array.isArray(value) || value.length !== 3) {
                // descriptionÏù¥ Ïù¥ÎØ∏ Ïã≠ÏßÑÎ≤ïÏù∏ Í≤ΩÏö∞
                if (typeof value === 'number') return value;
                if (value?.description && typeof value.description === 'number') return value.description;
                return null;
              }
              const [degrees, minutes, seconds] = value;
              return degrees + minutes / 60 + seconds / 3600;
            };

            const latValue = tags['GPSLatitude'].description || convertGPS(tags['GPSLatitude'].value);
            const lonValue = tags['GPSLongitude'].description || convertGPS(tags['GPSLongitude'].value);

            if (latValue && lonValue) {
              gpsData = {
                latitude: latValue,
                longitude: lonValue,
                altitude: tags['GPSAltitude']?.description || tags['GPSAltitude']?.value,
              };
              console.log('üìç GPS Ï†ïÎ≥¥ Ï∂îÏ∂ú:', gpsData);
            }
          }

          // Ïπ¥Î©îÎùº Ï†ïÎ≥¥ Ï∂îÏ∂ú
          const make = tags['Make']?.description || tags['Make']?.value || tags['271']?.description;
          const model = tags['Model']?.description || tags['Model']?.value || tags['272']?.description;
          
          metadata = {
            // Ïπ¥Î©îÎùº Ï†ïÎ≥¥
            make: make,
            model: model,
            
            // ÎÇ†Ïßú Ï†ïÎ≥¥
            dateTimeOriginal: tags['DateTimeOriginal']?.description || tags['DateTime']?.description || tags['CreateDate']?.description,
            createDate: tags['CreateDate']?.description || tags['DateTimeDigitized']?.description,
            
            // ÎπÑÎîîÏò§ ÌÅ¨Í∏∞
            width: tags['ImageWidth']?.value || tags['PixelXDimension']?.value || tags['Image Width']?.value,
            height: tags['ImageHeight']?.value || tags['PixelYDimension']?.value || tags['Image Height']?.value,
            
            // ÎπÑÎîîÏò§ Í¥ÄÎ†®
            duration: tags['Duration']?.value || tags['MediaDuration']?.value,
            
            // Ï¥¨ÏòÅ ÏÑ§Ï†ï
            iso: tags['ISOSpeedRatings']?.value || tags['ISO']?.value,
            fNumber: tags['FNumber']?.value || tags['FNumber']?.description,
            exposureTime: tags['ExposureTime']?.description || tags['ExposureTime']?.value,
            focalLength: tags['FocalLength']?.value || tags['FocalLength']?.description,
            
            // GPS
            gps: gpsData,
            
            // Í∏∞ÌÉÄ
            orientation: tags['Orientation']?.value || tags['Orientation']?.description,
            software: tags['Software']?.description || tags['Software']?.value,
            lensModel: tags['LensModel']?.description || tags['LensMake']?.description,
          };

          console.log('üé• Video EXIF metadata extracted:', metadata);
        } catch (videoExifError) {
          console.log('‚ö†Ô∏è Video EXIF extraction failed, using ffprobe as fallback');

          // ffprobeÎ°ú ÎπÑÎîîÏò§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÎèÑ
          try {
            const { exec } = await import('child_process');
            const { promisify } = await import('util');
            const execAsync = promisify(exec);

            const { stdout } = await execAsync(
              `ffprobe -v quiet -print_format json -show_format -show_streams "${filePath}"`
            );

            const ffprobeData = JSON.parse(stdout);
            const videoStream = ffprobeData.streams?.find((s: any) => s.codec_type === 'video');

            // ffprobeÏóêÏÑú Ï∂îÏ∂úÌïú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌÉúÍ∑∏Îì§
            const formatTags = ffprobeData.format?.tags || {};
            
            
            // GPS Ï†ïÎ≥¥ Ï∂îÏ∂ú (com.apple.quicktime.location.ISO6709 ÌòïÏãù)
            let gpsData = null;
            if (formatTags['com.apple.quicktime.location.ISO6709']) {
              const locationStr = formatTags['com.apple.quicktime.location.ISO6709'];
              // +37.5275+126.8977+080.000/ ÌòïÏãù ÌååÏã±
              const match = locationStr.match(/([+-]\d+\.?\d*)([+-]\d+\.?\d*)([+-]\d+\.?\d*)?/);
              if (match) {
                gpsData = {
                  latitude: parseFloat(match[1]),
                  longitude: parseFloat(match[2]),
                  altitude: match[3] ? parseFloat(match[3]) : undefined,
                };
                console.log('üìç GPS from ffprobe:', gpsData);
              }
            }

            if (videoStream) {
              metadata = {
                // ÎπÑÎîîÏò§ Ï†ïÎ≥¥
                width: videoStream.width,
                height: videoStream.height,
                duration: parseFloat(ffprobeData.format?.duration || 0),
                bitrate: parseInt(ffprobeData.format?.bit_rate || 0),
                codec: videoStream.codec_name,
                
                // Ïπ¥Î©îÎùº Ï†ïÎ≥¥ (QuickTime ÌÉúÍ∑∏ÏóêÏÑú Ï∂îÏ∂ú)
                make: formatTags['com.apple.quicktime.make'] || 'Apple',
                model: formatTags['com.apple.quicktime.model'] || formatTags['com.apple.quicktime.software'],
                
                // ÎÇ†Ïßú Ï†ïÎ≥¥
                dateTimeOriginal: formatTags['creation_time'] || formatTags['com.apple.quicktime.creationdate'],
                createDate: formatTags['creation_time'],
                
                // GPS
                gps: gpsData,
                
                // Í∏∞ÌÉÄ Ï†ïÎ≥¥
                software: formatTags['com.apple.quicktime.software'],
                orientation: videoStream.rotation,
              };

              console.log('üé• FFprobe metadata:', metadata);
            }
          } catch (ffprobeError) {
            console.warn('‚ö†Ô∏è FFprobe not available:', ffprobeError);
          }
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è EXIF extraction failed:', error);
      // SharpÎ°ú Í∏∞Î≥∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÎèÑ
      try {
        const sharpMetadata = await sharp(filePath).metadata();
        metadata = {
          width: sharpMetadata.width,
          height: sharpMetadata.height,
          format: sharpMetadata.format,
        };
        console.log('üì∏ Sharp metadata:', metadata);
      } catch (sharpError) {
        console.warn('‚ö†Ô∏è Sharp metadata extraction failed:', sharpError);
      }
    }

    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ïÍ∑úÌôî
    const normalizedMetadata = normalizeMetadata(metadata);
    console.log('üì∏ Normalized metadata:', {
      width: normalizedMetadata.width,
      height: normalizedMetadata.height,
      cameraMake: normalizedMetadata.cameraMake,
      cameraModel: normalizedMetadata.cameraModel,
      takenAt: normalizedMetadata.takenAt,
      iso: normalizedMetadata.iso,
    });

    // Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±
    let thumbnailPath = null;

    // Ïù¥ÎØ∏ÏßÄ Ïç∏ÎÑ§Ïùº
    if (file.type.startsWith('image/')) {
      try {
        const thumbnailDir = path.join(groupDir, 'thumbnails');
        if (!existsSync(thumbnailDir)) {
          await mkdir(thumbnailDir, { recursive: true });
        }

        const thumbnailName = `thumb_${fileName.replace(extension, '.jpg')}`;
        thumbnailPath = path.join(thumbnailDir, thumbnailName);

        // HEIC ÌååÏùº ÌäπÎ≥Ñ Ï≤òÎ¶¨ - JPEG Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±
        if (file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')) {
          console.log(`üîÑ Converting HEIC to JPEG thumbnail...`);

          // heic-converterÎ•º ÏÇ¨Ïö©ÌïòÏó¨ JPEG Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±
          const thumbnailBuffer = await convertHeicToThumbnail(filePath, 300);

          if (thumbnailBuffer) {
            // Ïç∏ÎÑ§Ïùº Î≤ÑÌçºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
            await writeFile(thumbnailPath, thumbnailBuffer);
            console.log(`‚úÖ HEIC thumbnail saved as JPEG: ${thumbnailPath}`);
          } else {
            console.warn(`‚ö†Ô∏è HEIC thumbnail conversion failed, will generate on-demand`);
            // Ïç∏ÎÑ§Ïùº ÏÉùÏÑ± Ïã§Ìå® Ïãú Í≤ΩÎ°úÎäî ÏÑ§Ï†ïÌïòÎêò ÎÇòÏ§ëÏóê ÎèôÏ†Å ÏÉùÏÑ±
          }
        } else {
          // ÏùºÎ∞ò Ïù¥ÎØ∏ÏßÄ Ïç∏ÎÑ§Ïùº ÏÉùÏÑ±
          await sharp(filePath)
            .rotate() // EXIF ÌöåÏ†Ñ Ï†ïÎ≥¥ Ï†ÅÏö©
            .resize(300, 300, {
              fit: 'inside',
              withoutEnlargement: true,
            })
            .jpeg({ quality: 80 })
            .toFile(thumbnailPath);
          console.log(`‚úÖ Image thumbnail generated: ${thumbnailPath}`);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Image thumbnail generation failed:', error);
      }
    }

    // ÎπÑÎîîÏò§ Ïç∏ÎÑ§Ïùº (Ï≤´ ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò) - MOV ÌååÏùº Ìè¨Ìï®
    if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mov')) {
      try {
        const thumbnailDir = path.join(groupDir, 'thumbnails');
        if (!existsSync(thumbnailDir)) {
          await mkdir(thumbnailDir, { recursive: true });
        }

        const thumbnailName = `thumb_${fileName.replace(extension, '.jpg')}`;
        const finalThumbnailPath = path.join(thumbnailDir, thumbnailName);

        console.log(`üé¨ Generating video thumbnail for: ${file.name}`);

        // ffmpeg Î™ÖÎ†πÏñ¥Î°ú Ï≤´ ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú
        const { exec } = await import('child_process');
        const { promisify } = await import('util');
        const execAsync = promisify(exec);

        try {
          // Í∞úÏÑ†Îêú ffmpeg Î™ÖÎ†πÏñ¥ - MOV ÌååÏùºÍ≥º ÌöåÏ†Ñ Ï†ïÎ≥¥ Ï≤òÎ¶¨
          // 1Ï¥à ÏßÄÏ†êÏùò ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú (Ï≤´ ÌîÑÎ†àÏûÑÏù¥ Í≤ÄÏùÄÏÉâÏùº Ïàò ÏûàÏùå)
          // ÏûêÎèô ÌöåÏ†Ñ Ï†ÅÏö© (-autorotate Í∏∞Î≥∏Í∞í)
          const ffmpegCmd = `ffmpeg -i "${filePath}" -ss 00:00:01 -vframes 1 -vf "scale=600:-1" -q:v 2 "${finalThumbnailPath}"`;

          await execAsync(ffmpegCmd);

          // Ïç∏ÎÑ§ÏùºÏù¥ ÏÉùÏÑ±ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
          if (existsSync(finalThumbnailPath)) {
            // SharpÎ°ú ÏµúÏ¢Ö Î¶¨ÏÇ¨Ïù¥Ï¶à Î∞è ÌíàÏßà Ï°∞Ï†ï
            const tempBuffer = await readFile(finalThumbnailPath);
            const optimizedBuffer = await sharp(tempBuffer)
              .resize(300, 300, {
                fit: 'inside',
                withoutEnlargement: true,
              })
              .jpeg({ quality: 85 })
              .toBuffer();

            // ÏµúÏ†ÅÌôîÎêú Î≤ÑÌçºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
            await writeFile(finalThumbnailPath, optimizedBuffer);

            thumbnailPath = finalThumbnailPath;
            console.log(`‚úÖ Video thumbnail generated: ${thumbnailPath}`);
          } else {
            console.warn('‚ö†Ô∏è Video thumbnail file not created');
          }
        } catch (ffmpegError) {
          console.warn('‚ö†Ô∏è ffmpeg thumbnail generation failed:', ffmpegError);
          // Ïã§Ìå® Ïãú Í∏∞Î≥∏ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
          try {
            const placeholderBuffer = await sharp({
              create: {
                width: 300,
                height: 300,
                channels: 3,
                background: { r: 44, g: 40, b: 36 },
              },
            })
              .composite([
                {
                  input: Buffer.from(
                    `<svg width="300" height="300" xmlns="http://www.w3.org/2000/svg">
                  <rect width="100%" height="100%" fill="#2c2824"/>
                  <polygon points="120,100 120,200 200,150" fill="white" opacity="0.7"/>
                </svg>`
                  ),
                  top: 0,
                  left: 0,
                },
              ])
              .jpeg({ quality: 80 })
              .toBuffer();

            await writeFile(finalThumbnailPath, placeholderBuffer);
            thumbnailPath = finalThumbnailPath;
            console.log('‚ö†Ô∏è Video placeholder thumbnail created');
          } catch (placeholderError) {
            console.error('Failed to create video placeholder:', placeholderError);
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Video thumbnail generation failed:', error);
      }
    }

    // ÎØ∏ÎîîÏñ¥ Ï†ïÎ≥¥Î•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
    // ÏÉÅÎåÄ Í≤ΩÎ°úÎ°ú Ï†ÄÏû• (ÏõπÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•Ìïú Í≤ΩÎ°ú)
    const relativePath = `/uploads/${groupId}/${fileName}`;
    const relativeThumbnailPath = thumbnailPath
      ? `/uploads/${groupId}/thumbnails/thumb_${fileName.replace(extension, '.jpg')}`
      : null;

    // Media Î¨∏ÏÑú ÏÉùÏÑ±
    const mediaData = {
      filename: fileName,
      originalName,
      path: relativePath,
      thumbnailPath: relativeThumbnailPath,
      mimeType: file.type || 'application/octet-stream',
      size: file.size,
      groupId,
      uploadedBy: decoded.userId,
      status: 'completed' as const,
      metadata: normalizedMetadata,
      uploadedAt: new Date(),
    };

    console.log('üìù Creating media document with data:', {
      filename: mediaData.filename,
      path: mediaData.path,
      groupId: mediaData.groupId,
      status: mediaData.status,
    });

    const media = await Media.create(mediaData);

    if (!media || !media._id) {
      throw new Error('Failed to create media document in database');
    }

    console.log(`‚úÖ Media saved to database: ${media._id}`);

    // Í∑∏Î£πÏùò ÎØ∏ÎîîÏñ¥ Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
    await Group.findByIdAndUpdate(groupId, {
      $inc: { mediaCount: 1 },
      $set: { updatedAt: new Date() },
    });

    // Í≤ÄÏ¶ù: Ïã§Ï†úÎ°ú Ï†ÄÏû•ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
    const savedMedia = await Media.findById(media._id);
    if (!savedMedia) {
      console.error('‚ùå Media was not properly saved to database');
      throw new Error('Media save verification failed');
    }

    console.log(`‚úÖ Media verified in database: ${savedMedia._id}`);

    return NextResponse.json({
      success: true,
      mediaId: media._id,
      filename: originalName,
      size: file.size,
      thumbnailPath: thumbnailPath ? `/api/media/thumbnail/${media._id}` : null,
    });
  } catch (error) {
    console.error('‚ùå Upload error:', error);
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : 'ÌååÏùº ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
      },
      { status: 500 }
    );
  }
}
